# 2217 로프(`sort`)
### 20210627SUN
-----------
### 문제
N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.

하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.

각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다
### 입력
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.
### 출력
첫째 줄에 답을 출력한다.
### 알고리즘 풀이
여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다.
최대 중량은? -> 최소 중량 * 로프 개수 아님?
```
s=[]
n = int(input())
for i in range(n):
  k = int(input())
  s.append(k)
print(n*s.min())
```
+++ python 리스트에서 최솟값 최댓값 구할 때 min(list) max(list)라고 써야 한다.list.min()아님 ! 주의하기
- 틀린이유 : 모든 로프를 사용해야 할 필요가 없고, 몇 개의 로프를 골라서 사용해도 되기 떄문이다. -> 그래 어쩐지 쉽더라.. 모든 로프를 사용할 떄랑 비교해봐야할듯 how?
- 일단 리스트를 정렬시킨다.
```
s=[]
n = int(input())
for i in range(n):
  k = int(input())
  s.append(k)
s.sort()
def compare(idx): #비교해주는 함수 정의/매개변수는 idx -> 리스트의 인덱스로 한다.
  if s[idx]*(len(s)-idx) < s[idx-1]*(len(s)-(idx+1)): #굳이 다 쓸필요가 없다는 것 -> 그렇지 않을 떄까지 계속 조사해야함
    compare(idx+1)
  else:
    print(s[idx]*(len(s)-idx))
```
- 내가 이렇게까지나 짤 수 있게되다니 좀 감격스러운걸...
- 주피터랩으로 돌려보자 -> output이 안나오는데...?
- 함수를 안 써줬다. 정의한 compare함수실행까지도 코드에 포함시켜보자.
```
s=[]
n = int(input())
for i in range(n):
  k = int(input())
  s.append(k)
s.sort()
def compare(idx): #비교해주는 함수 정의/매개변수는 idx -> 리스트의 인덱스로 한다.
  if s[idx]*(len(s)-idx) < s[idx-1]*(len(s)-(idx+1)): #굳이 다 쓸필요가 없다는 것 -> 그렇지 않을 떄까지 계속 조사해야함
    compare(idx+1)
  else:
    print(s[idx]*(len(s)-idx))
compare(0)
```
- <틀렸습니다>가 떴다.
- 틀린이유 : 순차적으로 계산하면 올바른 답이 안나올수도 있다. 그냥 리스트로 만들어서 max(리스트)로 구해주자
```
s=[]
s_=[]
n = int(input())
for i in range(n):
  k = int(input())
  s.append(k)
s.sort()
for idx in range(n):
  s_.append((len(s)-idx)*s[idx])
print(max(s_))
```
- 맞았다 !
